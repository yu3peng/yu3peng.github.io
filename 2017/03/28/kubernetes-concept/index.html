<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>Kubernetes的基本概念 &mdash; Yu Peng</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://y2p.cc/2017/03/28/kubernetes-concept/"><link rel="alternate" type="application/atom+xml" title="Yu Peng" href="https://y2p.cc/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/favicon.ico"><meta property="og:title" content="Kubernetes的基本概念"><meta name="keywords" content="yupeng"><meta name="og:keywords" content="yupeng"><meta name="description" content="Kubernetes 的基本概念"><meta name="og:description" content="Kubernetes 的基本概念"><meta property="og:url" content="https://y2p.cc/2017/03/28/kubernetes-concept/"><meta property="og:site_name" content="Yu Peng"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2017-03-28"> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170170785-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-170170785-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://y2p.cc/" title="Yu Peng"><span class="octicon octicon-mark-github"></span> Yu Peng</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://y2p.cc/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://y2p.cc/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://y2p.cc/notes/" class=" site-header-nav-item" target="" title="笔记">笔记</a> <a href="https://y2p.cc/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="Kubernetes的基本概念"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">Kubernetes的基本概念</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2017/03/28 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://y2p.cc/categories/#Kubernetes" title="Kubernetes">Kubernetes</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 3714 字，约 11 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>Kubernetes 的基本概念</p><h2 id="设计理念">设计理念</h2><p>用户定义应用程序的规格，Kubernetes 负责按照定义的规格部署并运行应用程序。</p><h2 id="kubernetes-特点">Kubernetes 特点</h2><ul><li>可移植: 支持公有云，私有云，混合云，多重云</li><li>可扩展: 模块化, 插件化, 可挂载</li><li>自动化: 自动部署，自动重启，自动伸缩</li></ul><h2 id="pod">Pod</h2><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/pod.png" alt="pod picture" /></p><h3 id="pod基本特性">Pod基本特性</h3><p>Pod是由一个或多个业务紧耦合的容器组成的容器组合，目前支持Docker容器技术，CoreOS的rkt等容器技术，并很容易扩展支持更多容器技术。</p><p>每个Pod都有一个被称为根容器的特殊容器：<code class="language-plaintext highlighter-rouge">Pause容器</code>，它对应的镜像属于Kubernetes平台的一部分。</p><p>为什么Kubernetes会设计出一个根容器？</p><p>原因之一：在一组容器作为一个单元的情况下，我们很难对<code class="language-plaintext highlighter-rouge">整体</code>简单地进行判断并有效地采取行动。比如一个容器死亡了，此时算是整体死亡吗？是N/M的死亡率吗？ 引入业务无关且不容易死亡的<code class="language-plaintext highlighter-rouge">Pause容器</code>，以它的状态代表整个容器的状态，就简单、巧妙地解决了这个难题。</p><p>原因之二：Pod里的多个业务容器共享<code class="language-plaintext highlighter-rouge">Pause容器</code>的IP，共享<code class="language-plaintext highlighter-rouge">Pause容器</code>挂架的Volume，这样既简化了密切关联的业务容器之间的通信问题，也很好地解决了它们之间的文件共享问题。</p><p>Pod中的所用容器会被一致调度、同节点部署，并且在一个<code class="language-plaintext highlighter-rouge">共享环境</code>中运行。这里的<code class="language-plaintext highlighter-rouge">共享环境</code>包括以下几点：</p><ol><li><p>所有容器共享一个IP地址，即<code class="language-plaintext highlighter-rouge">Pause容器</code>的IP地址，以及端口空间，意味着容器之间可以通过localhost高效访问，不能有端口冲突</p></li><li><p>允许容器之间共享存储卷，即<code class="language-plaintext highlighter-rouge">Pause容器</code>挂接的Volume，通过文件系统交互信息</p></li><li><p>容器之间可以通过IPC（inter-processcommunication)进行通信</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_pod.png" alt="pod" /></p><p>Pod有两种类型：普通Pod和Static Pod，后者比较特殊，它的信息并不保存在etcd中，而是存放在某个具体的Node上的一个具体文件中，并且只在此Node上启动运行。 而普通Pod一旦被创建，其信息会被放到etcd中存储，随后被Kubernetes Master调度到摸个具体的Node上并被绑定，随后该Pod被对应的Node上kubelet进程实例化成一组相关的Docker容器并启动起来。</p><p>从生命周期来说，Pod应该是短暂的而不是长久的应用。 Pods被调度到节点，保持在这个节点上直到被销毁。当节点死亡时，分配到这个节点的Pods将会被删掉。在实际使用时，我们一般不直接创建Pods, 我们通过replication controller来负责Pods的创建，复制，监控和销毁。</p><h3 id="pod应用场景">Pod应用场景</h3><p>Pod的主要目的还是支持需要一起部署、一起管理的进程，包括：</p><ol><li><p>内容管理系统，文件和数据加载进程，本地cache管理进程等</p></li><li><p>日志压缩、备份、快照等</p></li><li><p>数据变化监听、日志和监控适配器，事件分发等</p></li><li><p>控制、管理、配置、升级程序</p></li></ol><h4 id="实际的使用场景">实际的使用场景:</h4><h5 id="业务服务需要收集日志">业务服务需要收集日志</h5><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_pod_1.png" alt="pod_1" /></p><p>某服务模块已经实现了一些核心的业务逻辑，并且稳定运行了一段时间，日志记录在了某个目录下，按照不同级别分别为 error.log、warning.log、info.log，现在希望收集这些日志并发送到统一的日志处理服务器上。</p><p>这时我们可以修改原来的服务模块，在其中添加日志收集、发送的服务，但这样可能会影响原来服务的配置、部署方式，从而带来不必要的问题和成本，也会增加业务逻辑和基础服务的藕合度。</p><p>如果使用Pod的方式，通过简单的编排，既可以保持原有服务逻辑、部署方式不变，又可以增加新的日志收集服务。</p><p>而且如果我们对所有服务的日志生成有一个统一的标准，或者仅对日志收集服务稍加修改，就可以将日志收集服务和其他服务进行Pod编排，提供统一、标准的日志收集方式。</p><p>这里的<code class="language-plaintext highlighter-rouge">核心业务服务</code>、<code class="language-plaintext highlighter-rouge">日志收集服务</code>分别是一个Docker镜像，运行在隔离的容器环境中。</p><h5 id="提供sshftp访问容器数据的能力">提供ssh、ftp访问容器数据的能力</h5><p>Docker Hub或者很多第三方的镜像并没有安装sshd的服务，不方便我们进入容器进行配置、代码的修改、调试，很多时候需要重新构建镜像、或者在镜像基础上安装sshd的服务，这都需要时间和一定的学习成本。</p><p>而通过Pod的方式，我们就可以将现有镜像和一个ssh、ftp镜像进行编排，获得操作容器内数据的能力。</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_pod_2.png" alt="pod_2" /></p><h5 id="代码自动更新">代码自动更新</h5><p>我们部署了一个node.js的应用，而且部署了几十、上百个节点，那么我希望这个应用可以定时的同步最新的代码，以便自动升级线上环境。</p><p>这时，我们当然也不希望改动原来的node.js 应用，可以开发一个Git代码仓库的自动同步服务，然后通过Pod的方式进行编排，并共享代码目录，就可以达到更新node.js应用代码的效果。</p><p>并且这个同步服务还可以同其他使用Git代码仓库的服务编排，实现同样的需求。</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_pod_3.png" alt="pod_3" /></p><h5 id="适配不同iaas平台的环境">适配不同IaaS平台的环境</h5><p>我们开发一个节点管理的agent，这个agent需要读取当前部署环境的一些信息，可以通过底层平台的API实现。</p><p>但是，当部署到AWS、阿里云、青云等不同平台时，API就无法统一了。这样，我们可以实现不同平台的适配服务来获取各自的信息，并且和agent通过Pod编排部署，在不改变agent逻辑的情况下，通过服务组合来适配于不同平台。</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_pod_4.png" alt="pod_4" /></p><p>其实，Kubernetes 的一些新的功能需求，也会建议先通过Pod的编排来解决，而不是直接修改Kubernetes的代码，可见Pod还是用处多多的。</p><h2 id="replication-controller">Replication controller</h2><p>复制控制器确保Pod的一定数量的份数(replica)在运行。如果超过这个数量，控制器会杀死一些，如果少了，控制器会启动一些。控制器也会在节点失效、维护的时候来保证这个数量。所以强烈建议即使我们的份数是1，也要使用复制控制器，而不是直接创建Pod。</p><p>它其实定义了一个期望场景，即声明某种Pod的副本数在任意时刻都符合某个预期，所以RC的定义包含了如下几个部分：</p><ol><li><p>Pod期待的副本数(replica)</p></li><li><p>用于筛选目标Pod的Label Selector</p></li><li><p>当Pod副本数量小于预期值的时候，用于创建新Pod的模板（template）</p></li></ol><p>由于Replication controller无法准确表达它的本意，在kubernetes 1.2的时候，它升级为一个新的概念：replica set，与RC当前存在的唯一区别是，replica set支持基于集合的Label selector，而RC只支持基于等式的Label selector。</p><p>在生命周期上讲，复制控制器自己不会终止，但是跨度不会比Service强。Service能够横跨多个复制控制器管理的Pods。而且在一个Service的生命周期内，复制控制器能被删除和创建。Service和客户端程序是不知道复制控制器的存在的。</p><p>复制控制器创建的Pods应该是可以互相替换的和语义上相同的，这个对无状态服务特别合适。</p><p>Pod是临时性的对象，被创建和销毁，而且不会恢复。复制器动态地创建和销毁Pod。虽然Pod会分配到IP地址，但是这个IP地址都不是持久的。</p><h2 id="service">Service</h2><p>Service定义了一个Pod的逻辑集合和一个服务的入口访问地址。</p><p>集合是通过定义Service时提供的Label Selector完成的。举个例子，我们假定有3个Pod来处理后端业务。这些后端备份逻辑上是相同的，前端不关心哪个后端在给它提供服务。虽然组成这个后端的实际Pod可能变化，前端客户端不会意识到这个变化，也不会跟踪后端。</p><p>Service就是用来实现这种分离的抽象。</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_service.png" alt="kubernetes_net" /></p><p>当在Master节点上创建Service时，Kubernetes会给它分配一个地址，这个地址即Cluster IP，假定为10.0.0.1，此地址从service-cluster-ip-range参数指定的地址池中分配，比如–service-cluster-ip-range=10.0.0.0/16。 假设这个Service的端口是1234。集群内的所有node节点上的kube-proxy都会注意到这个Service。 当kube-proxy发现一个新的service后，它会在本地节点打开一个任意端口，建立相应的iptables规则，重定向Cluster IP和port到这个新建的端口，开始接受到达这个服务的连接。</p><p>当一个客户端访问这个service时，这些iptable规则就开始起作用，客户端的流量被重定向到kube-proxy为这个service打开的端口上，kube-proxy随机选择一个后端Pod来服务客户。这个流程如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/kubernetes_cluster_ip.png" alt="kubernetes_cluster_ip" /></p><p>在kubernetes集群内，Node IP、Pod IP、Cluster IP 之间的通信，采用的是kubernetes自己设计的一种特殊的路由规则，与我们熟悉的IP路由有很大不同。</p><p>对于每个service，我们通常需要配置一个负载均衡实例来转发到对应的Node上，这的确增加了工作量以及出错率，于是kubernetes提供了自动化的解决方案，如果我们的集群运行在google的GCE公有云上，那么我们只要把service的type=NodePort修改为type=LoadBalance，此时kubernetes会自动创建一个对应的LoadBalance实例并返回它的IP地址供外部客户端使用。</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://y2p.cc" target="_blank">Yu Peng</a></li><li>本文链接：<a href="https://y2p.cc/2017/03/28/kubernetes-concept/" target="_blank">https://y2p.cc/2017/03/28/kubernetes-concept/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,facebook'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2017/03/28/kubernetes-concept/', clientID: 'b2ad054f2e4daf7ad564', clientSecret: 'c742e4086336e58b70e0e88dc791e5bce6e37330', repo: 'blog-comments', owner: 'yu3peng', admin: ['yu3peng'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@built/assets/search_data.json?v=1651907438', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 30, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2022 <span title="Yu Peng">Yu Peng</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/yu3peng/yu3peng.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://y2p.cc/" title="首页" target="">首页</a></li><li> <a href="https://y2p.cc/categories/" title="分类" target="">分类</a></li><li> <a href="https://y2p.cc/notes/" title="笔记" target="">笔记</a></li><li> <a href="https://y2p.cc/about/" title="关于" target="">关于</a></li><li><a href="https://y2p.cc/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
