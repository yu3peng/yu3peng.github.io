<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>微服务探讨 &mdash; Yu Peng</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/rouge-themes@master/dist/github.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="https://y2p.cc/2017/05/02/microservice/"><link rel="alternate" type="application/atom+xml" title="Yu Peng" href="https://y2p.cc/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/favicon.ico"><meta property="og:title" content="微服务探讨"><meta name="keywords" content="yupeng"><meta name="og:keywords" content="yupeng"><meta name="description" content="微服务探讨"><meta name="og:description" content="微服务探讨"><meta property="og:url" content="https://y2p.cc/2017/05/02/microservice/"><meta property="og:site_name" content="Yu Peng"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2017-05-02"> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170170785-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-170170785-1'); </script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://y2p.cc/" title="Yu Peng"><span class="octicon octicon-mark-github"></span> Yu Peng</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://y2p.cc/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://y2p.cc/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://y2p.cc/notes/" class=" site-header-nav-item" target="" title="笔记">笔记</a> <a href="https://y2p.cc/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="微服务探讨"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">微服务探讨</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2017/05/02 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://y2p.cc/categories/#Architecture" title="Architecture">Architecture</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 6085 字，约 18 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><p>微服务探讨</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/microservice-vs-tradition.png" alt="microservice-vs-tradition" /></p><h2 id="微服务">微服务</h2><h3 id="目的">目的</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>有效地拆分应用，实现敏捷开发和部署
</code></pre></div></div><p>最终的目标是实现敏捷开发和部署，实现的方式是围绕业务能力<strong><em>有效地拆分应用</em></strong>。 微服务就是从各种角度，包括组织的、技术的等来阐释怎样有效地拆分应用，相对于其他拆分应用的方式，例如<a href="http://www.colorvps.com/help/topic/cloud/3020.html">六边形架构</a>、<a href="https://12factor.net/zh_cn/">12-Factor</a>以及<a href="https://book.douban.com/subject/4160830/">《The art of scalability》</a>涉及的方面更多。</p><h3 id="定义">定义</h3><p>微服务的流行，Martin功不可没，那我们就来看看在<a href="https://www.martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler</a>的文章中，微服务是怎么定义的</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The microservice architectural style is an approach to developing a single
application as a suite of small services, each running in its own process and
communicating with lightweight mechanisms, often an HTTP resource API. These services
are built around business capabilities and independently deployable by fully
automated deployment machinery. There is a bare minimum of centralized management of
these services, which may be written in different programming languages and use
different data storage technologies.
</code></pre></div></div><p>翻译成中文就是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>微服务架构即是采用一组小服务来构建应用的方法。
每个服务运行在独立的进程中，不同服务通过一些轻量级交互机制来通信， 例如 RPC、HTTP 等。
服务围绕业务能力来构建，并依赖自动部署机制来独立部署。
</code></pre></div></div><p>虽然勾勒出了微服务的一些关键概念：<strong><em>小、独立进程、自动化</em></strong>，但是这样的定义还是太抽象，太务虚，很难落地。<strong><em>一解释以为懂了，一问还是不知道，一讨论就打架</em></strong>。换句话说，就是<strong><em>道可道，非常道</em></strong>。</p><p>从Martin作为ThoughtWorks公司的首席科学家的角度来看，他把微服务“炒”起来了，如果像<a href="https://12factor.net/zh_cn/">12-Factor</a>写得这样具体实在，那咨询业务还怎么开展呢。</p><p>相比于Martin的文章，Chris Richardson的文章<a href="http://microservices.io/">microservices.io</a>就要具体多了，它从更多角度来阐释了微服务。</p><h3 id="起源">起源</h3><p>从微服务的定义，我们感觉似曾相识。早在 1994 年 Mike Gancarz 曾提出了 <a href="https://en.wikipedia.org/wiki/Unix_philosophy#Mike_Gancarz%3a_The_UNIX_Philosophy">9 条著名原则</a>，其中前 4 条和微服务架构理念特别接近。<a href="https://vanilla-java.github.io/2016/03/22/Micro-services-for-performance.html">微服务就像把 UNIX 哲学应用到了分布式系统</a>。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Small is beautiful.
2. Make each program do one thing well.
3. Build a prototype as soon as possible.
4. Choose portability over efficiency.
</code></pre></div></div><p>翻译成中文就是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 小即是美：小的服务，代码少，bug 也少，易测试，易维护，也更容易不断迭代完善。
2. 一个程序只做好一件事：一个服务也只需要做好一件事。
3. 尽可能早地创建原型：尽可能早的提供服务 API，建立服务契约，达成服务间沟通的一致性约定，
   至于实现和完善可以慢慢再做。
4. 可移植性比效率更重要：服务间的交互协议在效率和可移植性二者间，首要考虑移植性。
</code></pre></div></div><p>可见微服务其实不是凭空产生的，它自有其历史渊源。而在微服务之前的十年，大家经常谈论的是一个叫 SOA（面向服务）的架构模式，它和微服务又是什么关系？在 Sam Newman 的<a href="https://book.douban.com/subject/25881698/">《Building Microservices》</a>一书中，作者对 SOA 和 Micorservices 的区别给出了定义：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>You should instead think of Microservices as a specific approach for SOA in the same way 
that XP or Scrum are specific approaches for Agile software development.
</code></pre></div></div><p>翻译成中文就是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>就像认为 XP 或者 Scrum 是敏捷软件开发的一种特定方法一样，
你也可以认为微服务架构是 SOA 的一种特定方法。
</code></pre></div></div><p>面向服务架构（SOA）的概念已有十多年，它提出了一种架构设计思想， 但没有给出标准的参考实现，而早期企业软件业界自己摸索了一套实践方式 —— 企业服务总线（ESB）。 但历史证明 ESB 的实现方案甚至在传统企业软件行业也未取得成功，Martin Fowler 在文中说正是因为 ESB 当年搞砸了很多项目， 投入几百万美金，产出几乎为零，因此 SOA 这个概念也蒙上了不详的标签，所以当微服务架构出现时， 其拥护者开始拒绝使用包裹着失败阴影的 SOA 这个标签，而直接称其为微服务架构（Microservices Architecture Style）， 让人以为是一套全新的架构思想，但事实上它的本质依然是 SOA 的一种实践方式。</p><h3 id="特征">特征</h3><p>Martin自己也说了，每个人对微服务都可以有自己的理解，不过大概的标准还是有一些的。</p><ol><li>分布式服务组成系统</li><li>按照业务而不是技术来划分组织</li><li>做有生命的产品而不是项目</li><li>智能终端与哑管道</li><li>去中心化</li><li>自动化运维（DevOps）</li><li>容错</li><li>快速演化</li></ol><h4 id="分布式服务组成系统">分布式服务组成系统</h4><p>传统实现组件的方式是通过库（library），库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。 通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。</p><h4 id="按照业务而不是技术来划分组织">按照业务而不是技术来划分组织</h4><p>直接理解就是：服务提供的能力和业务功能对应。 比如：订单服务和数据访问服务，前者反应了真实的订单相关业务，后者是一种技术抽象服务不反应真实的业务。所以按微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。 更深一层，Melvin Conway 在 1967 年观察到一个现象并总结出了一条著名的<a href="https://en.wikipedia.org/wiki/Conway%27s_law">康威定律</a></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Organizations which design systems are constrained to produce designs 
which are copies of the communication structures of these organizations.
</code></pre></div></div><p>翻译成中文就是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>设计系统的组织，其产生的设计等同于组织之内、组织之间的沟通结构。
</code></pre></div></div><p>通俗的说法就是：<strong><em>组织形式等同系统设计</em></strong>。 看看下面的图片（来自互联网），再想想Apple的产品、微软的产品设计，就能形象生动的理解这句话。 <img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/conway-law.png" alt="conway-law" /> 就像<a href="http://www.colorvps.com/help/topic/cloud/3020.html">六边形架构</a>是微服务的理论基础之一一样，<a href="https://yq.aliyun.com/articles/8611">康威定律也是微服务架构的理论基础</a>之一。</p><p>传统开发方式中，我们将工程师按技能专长分层为前端层、中间层、数据层，前端对应的角色为 UI、页面构建师等，中间层对应的角色为后端业务开发工程师，数据层对应着 DBA 等角色。 事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构。所以若要按微服务的方式来构建应用，也需要对应调整团队的组织架构。每个服务背后的小团队的组织是跨功能的，包含实现业务所需的全面的技能。</p><h4 id="做有生命的产品而不是项目">做有生命的产品而不是项目</h4><p>传统的应用开发都是基于项目模式的，开发团队根据一堆功能列表开发出一个软件应用并交付给客户后，该软件应用就进入维护模式，由另一个维护团队负责，开发团队的职责结束。 而微服务架构建议避免采用这种项目模式，更倾向于让开发团队负责整个产品的全部生命周期。Amazon 对此提出了一个观点：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>You build it, you run it.
</code></pre></div></div><p>开发团队对软件在生产环境的运行负全部责任，让服务的开发者与服务的使用者（客户）形成每日的交流反馈，来自直接客户的反馈有助于开发者提升服务的品质。</p><h4 id="智能终端与哑管道">智能终端与哑管道</h4><p>微服务架构抛弃了 ESB 过度复杂的业务规则编排、消息路由等。 服务作为智能终端，所有的业务智能逻辑在服务内部处理，而服务间的通信尽可能的轻量化，不添加任何额外的业务规则。所以这里的智能终端是指服务本身，而哑管道是通信机制，可以是同步的 RPC，也可以是异步的 MQ，它们只作为消息通道，在传输过程中不会附加额外的业务智能。</p><h4 id="去中心化">去中心化</h4><p>去中心化包含两层意思：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 技术栈的去中心化。
2. 数据去中心化。
</code></pre></div></div><p>每个服务面临的业务场景不同，可以针对性的选择合适的技术解决方案。但也需要避免过度多样化，结合团队实际情况来选择取舍，要是每个服务都用不同的语言的技术栈来实现，想想维护成本真够高的。</p><p>每个服务独享自身的数据存储设施（缓存，数据库等），不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，隔离相关干扰。</p><h4 id="自动化运维">自动化运维</h4><p>无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着开发、调试、测试、监控和部署的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。</p><h4 id="容错">容错</h4><p>著名的 Design For Failure 思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略其中任何一点都属于对“分布式计算的误解”。</p><h4 id="快速演化">快速演化</h4><p>一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约（接口）的兼容性。一条普适的健壮性原则，<a href="https://en.wikipedia.org/wiki/Robustness_principle">伯斯塔尔法则</a>，给出了很好的建议：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Be conservative in what you send, be liberal in what you accept.
</code></pre></div></div><p>翻译成中文就是</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>发送时要保守，接收时要开放。
</code></pre></div></div><p>通俗的说法就是：<strong><em>宽进严出</em></strong></p><h3 id="实施">实施</h3><h4 id="前提">前提</h4><p>微服务虽然很火热，但它不是一枚<strong><em>银弹</em></strong>。它帮助大型应用打散和转移了复杂性，使其可以被更高效的并行解决，但并没有减少任何复杂性，甚至还引入了额外的分布式计算固有的复杂性。 所以什么时候该选择微服务架构，是一个权衡利弊的结果。 <img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/microservice-monolith.png" alt="microservice-monolith" /></p><p>上面的图来自 <a href="https://martinfowler.com/bliki/MicroservicePremium.html">Martin Fowler 的文章</a>，揭示了生产率和复杂度的一个关系。在复杂度较小时采用单体应用（Monolith）的生产率更高，复杂度到了一定规模时，单体应用的生产率开始急剧下降，这时对其进行微服务化的拆分才是合算的。</p><p>图上标明了复杂度和生产率拐点的存在，但并没有量化复杂度的拐点到底是多少？或者换种说法系统或代码库的规模达到具体多大才适合开始进行微服务化的拆分。在一篇有趣的文章<a href="http://blog.jobbole.com/76139/">《程序员职业生涯中的 Norris 常数》</a>中提到大部分普通程序员成长生涯的瓶颈在 2 万行代码左右。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>当代码是在 2,000 行以下，你可以写任何混乱肮脏的代码并依靠你的记忆拯救你。
深思熟虑的类和包分解会让你的代码规模达到 20,000 行。
</code></pre></div></div><p>两万行是作者经历过并反复碰到的一个瓶颈点。</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>初级程序员，学会了爬行，接着蹒跚学步，然后行走，然后慢跑，然后再跑步，最后冲刺，
他认为，“以这样加速度前进我可以赶上超音速喷气式飞机的速度！“ 
但他跑进了 2,000 行的极限，因为他的技能不会再按比例增加。
他必须改变移动方式，比如开车去获得更快的速度。然后，他就学会了开车，
开始很慢，然后越来越快，但又进入到了 20,000 行的极限。
驾驶汽车的技术不会让你能够开喷气式飞机。
</code></pre></div></div><p>所以每一个瓶颈点的突破意味着需要新的技能和技巧，而结合我自己的经历和经验，微服务的合适拆分拐点可能就在两万行代码规模附近，而每个微服务的规模大小最好能控制在一个普通程序员的舒适维护区范围内。借用前面的比喻，一个受过职业训练的普通程序员就像一个拿到驾照的司机，一般司机都能轻松驾驭 100 公里左右的时速，但很少有能轻松驾驭 200 公里或以上时速的司机，即使能够风险也是很高的。而能开喷气式飞机的飞行员级别的程序员恐怕在大部分的团队里一个也没有。</p><p>另外一个实施前提是基础设施的自动化，把 1 个应用进程部署到 1 台主机，部署复杂度是 1 x 1 = 1，若应用规模需要部署 200 台主机，那么部署复杂度是 1 x 200 = 200。 把 1 个应用进程拆分成了 50 个微服务进程，则部署复杂度变成了 50 x 200 = 10000，缺乏自动化设施，光部署就会把人搞死。所以前面微服务的特征才有基础设施自动化，这和规模也是有关的，这也是因为其运维复杂度的乘数级飙升， 从开发之后的构建、测试、部署都需要一个高度自动化的环境来支撑才能有效降低边际成本。</p><h4 id="维度">维度</h4><p>实施微服务架构，可以从下面一些维度来做全面考量。</p><h5 id="建模">建模</h5><p>微服务只是从软件实现的结果说事，没有提供一套方法论来对复杂系统进行分解，从而得到一个个微服务。 依照服务围绕业务能力来构建的方式，DDD（Domain Driven Design）中的<strong><em>BoundedContext</em></strong>，它是针对复杂系统设计的一套软件工程方法：把系统分割为一个个有边界的上下文，正好契合了微服务的这一需求。 BoundedContext，有一个比喻比较贴切：“细胞之所以会存在，是因为细胞膜定义了什么在细胞内，什么在细胞外，并且确定了什么物质可以通过细胞膜。”</p><h5 id="协作">协作</h5><p>采用微服务架构模式后，开发和运维的协作模式都会发生变化。 按微服务的组织方式，不同人或小团队负责一个或一组微服务，服务之间可能存在相互调用关系，所以在服务之间也完全采用了面向外部开放的契约化开发模式。 每一个服务都提供了一份契约文档，发布到公开的内部 wiki，方便服务干系人可自由获取查看。契约文档要求至少对服务的几个基本方面作出说明，如下：</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. API，具体接口的 API 接入技术说明。
2. 能力，服务能力的描述。
3. 契约，提供这些能力所约定的一些限制条件说明。
4. 版本，支持的最新和历史的版本说明。
</code></pre></div></div><p>使用契约文档来减少多余且可能反复重复的口头沟通，降低协作成本。</p><p>采用微服务后一个业务功能的调用会涉及多个服务间的协同工作，由于服务间都是跨进城的调用通信，一个业务功能的完成涉及的服务调用链条可能较长，这就涉及到服务间需遵循一些规则来确保协作的可靠性和可用性。我们采用的原则是：长链条的内部服务之间的调用异步化。若一个调用链条中的个别服务变慢或阻塞可能导致整个链条产生雪崩效应，采用异步化来规避调用阻塞等待导致的雪崩情形。</p><h5 id="测试">测试</h5><p>测试从不同的维度可以划分，如下四个象限，四个象限从不同维度视角对测试做了观察和判断，从中可以看出除了体验和探索性测试需要人工介入，其他维度的测试都可以通过自动化来实现，以降低测试人工成本和重复性工作。</p><p><img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/microservice-test.png" alt="microservice-test" /></p><p>而从测试所处的层次，又可以得到下面这样个一个测试金字塔： <img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/microservice-test-level.png" alt="microservice-test-level" /> 而微服务的测试，服务开发和运营人员专注于做好服务实现层面的单元测试和服务契约层面的接口测试。而面向业务功能的端到端测试，更多是依赖自动化脚本完成。而为了维护好这些自动化测试脚本，也需要保持服务接口和契约的兼容性和稳定性，这些自动化测试脚本也属于服务的消费方之一。</p><h5 id="监控">监控</h5><p>大量松耦合的微服务通过相互协作来完成业务功能的流程处理，在这样一个复杂的生产环境中，出现异常或错误是很难迅速定位的。 对监控进行分层，顶层的监控站在用户视角，底层的监控站在系统视角，形成更完善的反馈链路。 <img src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/images/posts/microservice-monitor.png" alt="microservice-monitor" /></p><h2 id="参考资料">参考资料</h2><ol><li><p><a href="http://www.cnblogs.com/mindwind/p/5422053.html">Microservice 微服务的理论模型和现实路径</a></p></li><li><p><a href="https://yq.aliyun.com/articles/2764">微服务（Microservice）那点事</a></p></li><li><p><a href="http://r12f.com/posts/reading-time-building-microservices/">微服务架构知识总结</a></p></li></ol><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://y2p.cc" target="_blank">Yu Peng</a></li><li>本文链接：<a href="https://y2p.cc/2017/05/02/microservice/" target="_blank">https://y2p.cc/2017/05/02/microservice/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"><div class="share-component" data-disabled='qq,facebook'></div></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2017/05/02/microservice/', clientID: 'b2ad054f2e4daf7ad564', clientSecret: 'c742e4086336e58b70e0e88dc791e5bce6e37330', repo: 'blog-comments', owner: 'yu3peng', admin: ['yu3peng'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>Search</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@built/assets/search_data.json?v=1651905739', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 30, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2022 <span title="Yu Peng">Yu Peng</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/yu3peng/yu3peng.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://y2p.cc/" title="首页" target="">首页</a></li><li> <a href="https://y2p.cc/categories/" title="分类" target="">分类</a></li><li> <a href="https://y2p.cc/notes/" title="笔记" target="">笔记</a></li><li> <a href="https://y2p.cc/about/" title="关于" target="">关于</a></li><li><a href="https://y2p.cc/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/yu3peng/yu3peng.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script></body></html>
